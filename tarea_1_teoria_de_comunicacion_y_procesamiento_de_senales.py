# -*- coding: utf-8 -*-
"""Tarea_1_Teoria_de_Comunicacion_y_Procesamiento_de_Senales.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1T5qjx2NB-wGzPQaJMJ_kdoDE5b7PjLbo

***Librerías***
"""

from math import log
from math import sqrt
import numpy as np
import matplotlib.pyplot as plt
from scipy.constants import k

"""***Ejercicio 1***

Para el desarrollo de este ejercicio, se propone el uso de diversas funciones auxiliares las cuales se explican a continuación:

***ingresar_datos():*** Esta función tiene como objetivo permitir el ingreso de todos los datos al programa y validarlos de acuerdo a las características del dato esperado. Valida tanto el rango, como el tipo de dato de entrada.

Argumentos:

1. lim_superior: se utiliza para limitar el rango del dato entrante (el límite inferior siempre es 0). En el caso especial, donde el valor de lim_superior sea 0 significa que el dato entrante no tiene ninguna limitación de rango, por lo cual solo se valida el tipo de dato. Tipo int.

Retorna:

* Retorna el dato que fue ingresado por el usuario. Tipo int o float.
"""

def ingresar_datos(lim_superior):
    while True:

        try:  # validacion del datos tipo int y float

            if lim_superior != 0:
                dato = int(input("Seleccion: "))

                if 0 < dato and dato < lim_superior:  # validacion del rango
                    return dato

                else:
                    print("El dato ingresado se encuentra fuera de rango.")

            else:  # limite superior = 0 -> ingreso de magnitudes
                dato = float(input("Valor: "))
                return dato

        except ValueError:
            print("El dato ingresado contiene caracteres no numericos o representacion flotante.")

"""***dBu_dBm():*** realiza la conversión de dBu a dBm.

Argumentos:

1. entrada: dato a convertir. Tipo float.

Retorna:

* El resultado de la conversion. Tipo float.
"""

def dBu_dBm(entrada):
    resultado = entrada - 30
    return resultado

"""***dBu_dbW():*** realiza la conversion de dBu a dbW.

Argumentos:

1. entrada: dato a convertir. Tipo float.

Retorna:

* El resultado de la conversion. Tipo float.
"""

def dBu_dbW(entrada):
    resultado = entrada - 60
    return resultado

"""***dBm_dBu()***: realiza la conversion de dBm a dBu.

Argumentos:

1. entrada: dato a convertir. Tipo float.

Retorna:

* El resultado de la conversion. Tipo float.
"""

def dBm_dBu(entrada):
    resultado = entrada + 30
    return resultado

"""***dBm_dbW()***: realiza la conversion de dBm a dbW.

Argumentos:

1. entrada: dato a convertir. Tipo float.

Retorna:

* El resultado de la conversion. Tipo float.
"""

def dBm_dbW(entrada):
    resultado = entrada - 30
    return resultado

"""***dbW_dBu():*** realiza la conversion de dbW a dBu.

Argumentos:

1. entrada: dato a convertir. Tipo float.

Retorna:

* El resultado de la conversion. Tipo float.
"""

def dbW_dBu(entrada):
    resultado = entrada + 60
    return resultado

"""***dbW_dBm():*** realiza la conversion de dbW a dBm.

Argumentos:

1. entrada: dato a convertir. Tipo float.

Retorna:

* El resultado de la conversion. Tipo float.
"""

def dbW_dBm(entrada):
    resultado = entrada + 30
    return resultado

"""***main1_1():*** En esta función se desarrolla el programa principal para la ejecución del ejercicio 1.1. No posee parámetros, ni valores de retorno. Los valores ingresados son mediante la consola por parte del usuario, y los resultados deseados se imprimen durante la ejecución de la misma."""

def main_1_1():
    #  ingreso de datos
    print("Dato de entrada:\n1.dBu\n2.dBm\n3.dBw")
    tipo_entrada = ingresar_datos(4)  # tipo de dato de entrada
    valor_entrada = ingresar_datos(0)  # valor del dato de entrada
    print("Dato de salida:\n1.dBu\n2.dBm\n3.dBw")
    unidad_salida = ingresar_datos(4)  # tipo de dato de salida
    resultado = []

    if tipo_entrada == 1:  # dato de entrada: dBu

        if unidad_salida == 2:  # conversion dBu -> dBm
            resultado.append(dBu_dBm(valor_entrada))
            resultado.append("dBm")
        elif unidad_salida == 3:  # conversion dBu -> dBW
            resultado.append(dBu_dbW(valor_entrada))
            resultado.append("dbW")
        else:  # no hay conversion dBu -> dBu
            print("Mismo tipo de entrada y salida, no hay conversion.")
            resultado.append(valor_entrada)
            resultado.append("dBu")

    elif tipo_entrada == 2:  # dato de entrada: dBm

        if unidad_salida == 1:  # conversion dBm -> dBu
            resultado.append(dBm_dBu(valor_entrada))
            resultado.append("dBu")
        elif unidad_salida == 3:  # conversion dBm -> dBW
            resultado.append(dBm_dbW(valor_entrada))
            resultado.append("dbW")
        else:  # no hay conversion dBm -> dBm
            print("Mismo tipo de entrada y salida, no hay conversion.")
            resultado.append(valor_entrada)
            resultado.append("dBm")

    elif tipo_entrada == 3:  # dato de entrada dBW

        if unidad_salida == 1:  # conversion dBW -> dBu
            resultado.append(dbW_dBu(valor_entrada))
            resultado.append("dBu")
        elif unidad_salida == 2:  # conversion dBW -> dBm
            resultado.append(dbW_dBm(valor_entrada))
            resultado.append("dBm")
        else:  # no hay conversion dBW -> dBW
            print("Mismo tipo de entrada y salida, no hay conversion.")
            resultado.append(valor_entrada)
            resultado.append("dbW")

    print("El resultado es {} {}".format(str(resultado[0]), resultado[1]))

"""***Ejecución del ejercicio 1.1***"""

main_1_1()

"""***Ejercicio 1.2:*** Con el uso de las funciones anteriormente descritas, se muestra el desarrollo del programa principal para ejecutar la parte 2 del ejercicio 1."""

def main_1_2():
    # ingreso de datos
    print("Dato de entrada:\n1.dBu\n2.dBm\n3.dBw\n4.Watt")
    tipo_entrada = ingresar_datos(5)  # tipo de dato de entrada
    valor_entrada = ingresar_datos(0)  # valor del dato de entrada
    resultado = []
    if tipo_entrada == 4:  # Entrada watt -> salida en dB's
        print("Dato de salida:\n1.dBu\n2.dBm\n3.dBw")
        unidad_salida = ingresar_datos(4)  # tipo de dB de salida
        resultado_dbW = 10*log(valor_entrada, 10)  # conversion watt -> dBW

        if unidad_salida == 1:  # salida en dBu
            resultado.append(dbW_dBu(resultado_dbW))
            resultado.append("dBu")
        elif unidad_salida == 2:  # salida en dBm
            resultado.append(dbW_dBm(resultado_dbW))
            resultado.append("dBm")
        else:  # salida en dBW
            resultado.append(resultado_dbW)
            resultado.append("dbW")

    else:  # Entrada en dB's -> salida en Watt

        if tipo_entrada == 1:  # entrada dBu
            resultado_dbW = dBu_dbW(valor_entrada)
        elif tipo_entrada == 2:  # entrada dBm
            resultado_dbW = dBm_dbW(valor_entrada)
        else:  # entrada dBW
            resultado_dbW = valor_entrada
        resultado.append(pow(10, resultado_dbW/10))  # conversion dBW a Watt
        resultado.append("W")

    print("El resultado es {} {}".format(str(resultado[0]), resultado[1]))

"""***Ejecución del ejercicio 1.2***"""

main_1_2()

"""***Ejercicio 2:***

Para el desarrollo de este ejercicio, se propone el uso de diversas funciones auxiliares las cuales se explican a continuación:

***puntos_grafica():*** Esta función tiene como objetivo crear los arrays de valores para el eje x y y, para funciones periodicas, diente de sierra, cuadrada y senoidal para este caso. Tiene 4 argumentos:

1.   amplitud: amplitud de la funcion periodica de la cual se desean generar los puntos. Tipo float o int.
2.   periodo: periodo de repetición de la funcion periodica de la cual se desean generar los puntos. Tipo float o int.
3.   cantidad_periodos: cantidad de veces que se desea que se repita la función. Tipo int.
4.   funcion: funcion periodica de la cual se desean generar los puntos. Tipo int (de 1 a 3, para otros valores se toma la funcion senoidal como default)
     - 1 -> Diente de Sierra
     - 2 -> Cuadrada
     - 3 -> Senoidal

Retorna 2 arrays:
1.   x -> Array con los valores de x correspondientes al periodo y cantidad de periodos solicitados.
2.   y -> Array con los valores de y correspondientes a la funcion solicitada.
"""

def puntos_grafica(amplitud, periodo, cantidad_periodos, funcion):
    x = np.linspace(0, periodo, 1000)  # 1er periodo de puntos en x

    # 1er periodo de puntos en y
    if funcion == 1:  # diente de sierra
        y1p = x*amplitud/periodo

    elif funcion == 2:  # onda cuadrada
        y1p = []
        for element in x:
            if element < periodo/2:
                y1p.append(0)
            else:
                y1p.append(amplitud)

    else:  # senoidal
        y1p = amplitud*np.sin(2*np.pi*x/periodo)

    x = np.linspace(0, periodo*cantidad_periodos, 1000*cantidad_periodos)  # array puntos en x
    y = []

    for _ in range(cantidad_periodos):  # generacion del array de puntos y completo
        for element in y1p:
          y.append(element)

    return x, y

"""***ruido():*** esta función tiene como objetivo modificar un array de datos, en este caso, la representación en "y" de una función, por un nuevo array con una componente de ruido aleatorio agregado proporcional a la amplitud de la función.

Tiene 3 argumentos:

1. y: array que se desea modificar agregándole ruido. Tipo array.
2. amplitud: amplitud de la función a la cual pertene el array. Tipo float o int.
3. nivel_ruido: nivel de ruido que se desea aplicar a la señal. Tipo int (en un rango de 1 a 3. Para otros valores el default es alto)
    - 1 -> bajo
    - 2 -> medio
    - 3 -> alto

Retorna:
- Nuevo array con la componente de ruido agregada. Tipo array.

"""

def ruido(y, amplitud, nivel_ruido):

    if nivel_ruido == 1:  # bajo
        nivel = amplitud*0.02

    elif nivel_ruido == 2:  # medio
        nivel = amplitud*0.05

    else:  #alto
        nivel = amplitud*0.10

    ruido = np.random.normal(scale=nivel, size=len(y))  # array de valores de ruido
    y_ruido = y + ruido  # se agrega el ruido

    return y_ruido

"""***graficar():*** esta función tiene como objetivo graficar un 2 conjuntos de datos (x, y) en un plano.

Tiene 4 argumentos:

1. x: array que contiene los datos que se van a graficar en x. Tipo array.
2. y: array que contiene los datos que se van a graficar en y. Tipo array.
3. funcion: nombre de la funcion que se va a graficar. Tipo str.
4. ruido: nivel de ruido que contiene la señal. Por default es "" para señales que no contienen ruido. Tipo str.

Retorna:
- No retorna ningún tipo de dato. Imprime los gráficos esperados durante su ejecución.
"""

def graficar(x, y, funcion, ruido = ""):
    plt.plot(x, y)
    plt.xlabel("x")  # nombre del eje x
    if ruido == "":  # caso sin ruido
        plt.ylabel("y")
        plt.title("Gráfica {} Sin Ruido".format(funcion))

    else:  # caso con ruido
        plt.ylabel("y_ruido")
        plt.title("Gráfica {} Con Nivel {} de Ruido".format(funcion, ruido))

    plt.show()  # impresion del grafico

"""***main_2():*** esta función contiene el programa principal para ejecutar el ejercicio 2. No tiene parámetros, ni retorna ningún valor, todos los valores esperados se imprimen durante su ejecución."""

def main_2():
    # ingreso de datos
    print("Elija la curva que desea generar:\n1.Diente de Sierra\n2.Cuadrada\n3.Senoidal")
    funcion = ingresar_datos(4)

    print("Elija el nivel de ruido que desea que tenga la curva:\n1.Bajo\n2.Medio\n3.Alto")
    nivel_ruido = ingresar_datos(4)

    print("Ingrese el valor de amplitud de la gráfica:")
    amplitud = ingresar_datos(0)

    print("Ingrese el valor de periodo de la gráfica:")
    periodo = ingresar_datos(0)

    print("Ingrese la cantidad de periodos que desea visualizar:")
    cantidad_periodos = int(ingresar_datos(0))

    x, y = puntos_grafica(amplitud, periodo, cantidad_periodos, funcion)  # generacion de los arrays para la gráfica
    y_ruido = ruido(y, amplitud, nivel_ruido)  # se genera la componente con ruido

    # listas con nombres utilizados para la rotulacion de las graficas
    funciones = ["Diente de Sierra", "Cuadrada", "Senoidal"]
    niveles = ["Bajo", "Medio", "Alto"]

    graficar(x, y, funciones[funcion - 1])  # grafica sin ruido
    graficar(x, y_ruido, funciones[funcion -1], niveles[nivel_ruido -1])  # grafica con ruido

"""Ejecución del ejercicio 2"""

main_2()

"""***Ejercicio 3***

***ruido_termico():*** esta función contiene el programa principal para ejecutar el ejercicio 3.1. No tiene parámetros, ni retorna ningún valor, todos los valores esperados se imprimen durante su ejecución.
"""

def ruido_termico():
		#ingreso de datos
		print("Elija la unidad de la temperatura:\n1. Kelvin\n2. Celsius\n3. Farenheit ")
		unidades_T = ingresar_datos(4)
		print("Ingrese la temperatura:")
		temp = ingresar_datos(0)
		print("Elija la unidad del ancho de banda:\n1. kHz\n2. MHz\n3. GHz")
		unidades_B = ingresar_datos(4)
		print("Ingrese el ancho de banda")
		ancho_banda = ingresar_datos(0)

		if unidades_T == 1:  # kelvin
				pass
		elif unidades_T == 2:  # celsius
				temp = temp + 273
		else:  # farenheit
				temp = (temp + 460)*(5/9)

		if unidades_B == 1:  # kHz
				ancho_banda = ancho_banda * (10 ** 3)
		elif unidades_B == 2:  # MHz
				ancho_banda = ancho_banda * (10 ** 6)
		else:  # GHz
				ancho_banda = ancho_banda * (10 ** 9)

		K = k  # constante de Boltzman
		ruido_t = ancho_banda*K*temp  #calculo del ruido termico
		print(ruido_t)
		ruido_t_db = 10 * log(ruido_t, 10)

		print("La magnitud de ruido termico es de:", ruido_t_db, "dBm")

"""***Ejecución del ejercicio 3.1***"""

ruido_termico()

"""***distorsion_armónica():*** esta función contiene el programa principal para ejecutar el ejercicio 3.2. No tiene parámetros, ni retorna ningún valor, todos los valores esperados se imprimen durante su ejecución."""

def distorsion_armónica():
    # ingreso de datos
    print("Ingrese la tensión RMS del armónico fundamental:")
    tension_rms = ingresar_datos(0)
    print("Digite el número de armónicos que presenta la señal: ")
    num_armonicos = int(ingresar_datos(0))

    armonic_list = []
    for n in range(num_armonicos):
        print("Ingrese el VRMS del armónico {}: ".format(str(n+1)))
        rms_armonico = ingresar_datos(0)  # valor rms de cada armonico
        rms_armonico_2 = rms_armonico ** 2  # valor rms^2 de cada armonico
        armonic_list.append(rms_armonico_2)

    V_sup_temp = 0
    for element in armonic_list:  # suma del valor rms^2 de cada armonico
        V_sup_temp = element + V_sup_temp
    V_sup = sqrt(V_sup_temp)
    porc_THD = (V_sup / tension_rms) * 100
    print ("La distorsión armonica total es de: ", porc_THD, "%")

"""***Ejecución del ejercicio 3.2***"""

distorsion_armónica()

"""amplificador_no_ideal(): esta función contiene el programa principal para ejecutar el ejercicio 3.3. No tiene parámetros, ni retorna ningún valor, todos los valores esperados se imprimen durante su ejecución."""

def amplificador_no_ideal():
    # ingreso de datos
    print("Ingrese la potencia de entrada en W: ")
    pot_entrada = ingresar_datos(0)
    print("Ingrese la potencia de ruido en W: ")
    pot_ruido = ingresar_datos(0)
    print("Ingrese la magnitud de ganacia de potencia: ")
    gan_potencia = ingresar_datos(0)
    print("Ingrese la magnitud de ruido interno: ")
    ruido_interno = ingresar_datos(0)

    entrada_temp = pot_entrada/pot_ruido
    S_N_entrada = 10 * log(entrada_temp, 10)
    print("S/N a la entrada en dB equivale a: ", S_N_entrada)

    salida_temp = (gan_potencia*pot_entrada)/(gan_potencia*pot_ruido+ruido_interno)
    S_N_salida = 10 * log(salida_temp, 10)
    print("S/N a la salida en dB equivale a: ", S_N_salida)

    factor_ruido = S_N_entrada/S_N_salida

    cifra_ruido = 10 * log(factor_ruido, 10)

    print("El factor de ruido es de: ", factor_ruido)
    print("La cifra de ruido es de: ", cifra_ruido)

"""***Ejecución del ejercicio 3.3***"""

amplificador_no_ideal()