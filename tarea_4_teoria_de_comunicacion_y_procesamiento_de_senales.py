# -*- coding: utf-8 -*-
"""Tarea_4_Teoria_de_Comunicacion_y_Procesamiento_de_Senales.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1C2qw2Bt0ifSriZwufBiG4DZo39XKs-E9

# Tarea 4: Modulación Digital

Integrantes:
- Jose Fabio Navarro Naranjo
- Emiliano Alfaro Chacón

## Descripción General

En este trabajo se abordará el tema de diseño de un sistema de modulación por pulsos y algunos aspectos generales de los esquemas de modulación digital, mediante la programación, análisis e investigación de los aspectos más relevantes asociados estos temas, se usará Python como el lenguaje de programación base.

## Parte 1

### Descripción

En esta sección se construirá un sistema de modulación por muestreo de pulsos (PAM)

### Implementación en Código

Importación de librerías
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

"""Definción de funciones"""

def graficar(x, y, title, fourier=1):

    if fourier:
        fig = plt.figure(figsize=(20, 4))
        ax1 = fig.add_subplot(1, 2, 1)
        ax2 = fig.add_subplot(1, 2, 2)

        # Tiempo
        ax1.plot(x, y)
        ax1.set_xlabel('Tiempo [s]')
        ax1.set_ylabel('Señal')
        ax1.set_title(title)
        ax1.grid()

        # Frecuencia
        n = len(y)
        freq = np.fft.fftfreq(n, d=x[1]-x[0])
        Y = np.fft.fft(y)
        Y_mag = np.abs(Y)
        ax2.plot(freq, Y_mag)
        ax2.set_xlabel('Frecuencia [Hz]')
        ax2.set_ylabel('Magnitud')
        ax2.set_title(str('Transformada de Fourier de la ' + title))
        ax2.grid()

    else:
        fig = plt.figure(figsize=(20, 4))

        # Tiempo
        plt.plot(x, y)
        plt.xlabel('Tiempo [s]')
        plt.ylabel('Señal')
        plt.title(title)
        plt.xticks(np.arange(0, 21, 1))
        plt.grid(True)

    plt.show()


def ingresar_datos():
    while True:
        try:  # validacion del datos tipo int

            dato = int(input("Seleccion: "))

            if 0 < dato and dato < 4:  # validacion del rango
                return dato

            else:
                print("El dato ingresado se encuentra fuera de rango.")

        except ValueError:
            print("El dato ingresado contiene caracteres no numericos o representacion flotante.")


def filtro_bajas(signal_in, fc, fs):
    wn = fc / (fs / 2)  # frecuencia normalizada

    order = 4  # orden del filtro
    b, a = signal.butter(order, wn, 'low')

    # Aplicar el filtro a la señal
    signal_out = signal.filtfilt(b, a, signal_in)
    return signal_out

"""Ejecución del programa"""

# Ingresar la señal que se desea modular:

print("Ingrese el tipo de señal que desea modular:\n1- Senoidal\n2- Cuadrada\n3- Triangular\n")
seleccion = ingresar_datos()

t = np.linspace(0, 0.5, 500)  # Vector de tiempo
f_senal = 4000

if seleccion == 1:  # Senoidal
    senal = np.sin(2*np.pi*f_senal*t)
    title = "Señal Senoidal"
    f_corte = 4000
    f_muestreo = 320000

elif seleccion == 2:  # Cuadrada
    senal = (1+np.sign(np.sin(2*np.pi*f_senal*t)))/2
    title = "Señal Cuadrada"
    f_corte = 8000
    f_muestreo = 320000

else:  # Triangular
    senal = signal.sawtooth(2 * np.pi * f_senal * t, 0.5)
    title = "Señal Triangular"
    f_corte = 16000
    f_muestreo = 160000

graficar(t, senal, title)

print("Ingrese el ancho de pulso de la señal de muestreo:\n1- Angosto\n2- Medio\n3- Ancho\n")
seleccion = ingresar_datos()

# Señal de muestreo
f_senal_muestreo = 20*f_senal

if seleccion == 1:  # Angosto
    ancho_pulso = 0.2

elif seleccion == 2:  # Mediana angostura
    ancho_pulso = 0.5

else:  # Ancho
    ancho_pulso = 0.8

muestreo = (signal.square(2 * np.pi * f_senal_muestreo * t, duty=ancho_pulso)+1)/2

senal_muestreada = senal*muestreo
graficar(t, senal_muestreada, str(title + " Muestreada"))

# Filtrar Señal

senal_filtrada = filtro_bajas(senal_muestreada,
                                 f_corte, f_muestreo)

graficar(t, senal_filtrada, str(title + " Filtrada"))

"""##Análisis de Resultados

Los resultados obtenidos para las diferentes curvas no muestran como tal el mensaje de entrada, esto se debe a varias razones, entre las cuales se destaca la falta de implementación de algunos elementos adicionales al sistema necesarios para una aproximación más elevada.
Algunos de estos elementos son:


*   Un filtro para el mensaje m(t), esto debido a la necesidad de limpiar ciertos armónicos.
*   Un ecualizador a la salida del filtro para eliminar picos indeseados, este no se implementa ya que no se solicita.


A su vez es posible verificar como al utilizar anchos de pulso muy angostos para la tasa de muestreo se producen inconsistencias para el filtro pues la frecuencia posee armónicos de muy alta frecuencia.


En cuanto al ancho de pulso, se puede observar que conforme menor es éste, mayor es el ancho de banda que se pued observar en el espectro de frecuencia de la onda ya filtrada, lo cual coincide con el comportamiento esperado para estos sistemas. De igual manera, conforme la onda empieza a ser más ancha, se puede notar que el ancho de banda comienza a reducirse.

##Parte 2

###Descripción

En esta sección se van a representar los esquemas ASK, FSK y PSK de una señal de entrada definida.

###Implementación en Código

Definición de Funciones
"""

def binary_2_plot(binary_list):

    # Repite cada valor de binary_list 100 veces
    y = np.repeat(binary_list, 100)

    # Genera una lista de valores x para la señal cuadrada
    x = np.linspace(0, 20, len(y))

    # Tamaño de la figura para el gráfico
    fig = plt.figure(figsize=(20, 2))

    # Grafica x vs y
    plt.plot(x, y)

    # Agrega etiquetas a los ejes y título
    plt.xlabel('Tiempo (s)')
    plt.ylabel('Amplitud')
    plt.title('Señal de entrada')

    # Establece los valores y etiquetas en el eje x
    plt.xticks(np.arange(0, 21, 1))

    # Activar el grid
    plt.grid(True)

    # Muestra la gráfica
    plt.show()

    return x, y

"""Ejecución del programa

Modulación digital

Existen 3 posibles casos: ASK, FSK, PSK.
La modulación por ASK o modulación por desplazamiento de amplitud utiliza un principio muy básico, en presencia de un 1 lógico se activa la señal del carrier y en presencia de un 0 lógico la salida tendrá una magnitud cero.
La modulación por FSK utiliza el principio de la modulación FM, es decir que modifica la frecuencia de la señal de salida. Se modificará la frecuencia en razón a la magnitud de la señal lógica de entrada, la presencia de un 1 provocará un aumento en la frecuencia.
La modulación PSK o modulación por desplazamiento de fase se basa la modificación de la fase de la señal del carrier, si se está en presencia de un 1 lógico se mantiene la señal de entrada, para un 0 lógico se desplazará en 90°.
"""

# Señal de entrada
binary_list = [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1]

# Graficar y obtener la señal de entrada graficada
t, y = binary_2_plot(binary_list)

# Señal moduladora
f_senal = 2
senoidal = np.cos(2*np.pi*f_senal*t)
graficar(t, senoidal, "Senal moduladora", 0)

# Señal ASK
ask = y*senoidal
graficar(t, ask, "ASK", 0)

# Señal FSK

# Señal moduladora de menor frecuencia
f_senal_2 = 1
senoidal_2 = np.cos(2*np.pi*f_senal_2*t)

fsk = []

for i in range(len(y)):
    if y[i] == 0:
        fsk.append(senoidal_2[i])
    else:
        fsk.append(senoidal[i])

graficar(t, fsk, "FSK", 0)

# Señal PSK
y_psk = list()

for i in range(len(y)):
    if y[i] == 0:
        y_psk.append(-1)
    else:
        y_psk.append(1)

psk = y_psk*senoidal
graficar(t, psk, "PSK", 0)

"""Los resultados obtenidos poseen un nivel de satisfacición elevado, es posible aseverar esto analizando las señales moduladas obtenidas. Para la señal ASK se puede notar como su comportamiento varía en razón a la señal lógica de entrada, provocando una magnitud de 0V en presencia de un cero lógico.
Para la señal FSK es posible notar a simple vista la variación de la frecuencia, aumentando la frecuencia en presencia de un 1 lógico.
Para la señal PSK es notorio el cambio de fase en razón al tren de pulsos, a su vez es posible visualizar como en presencia de un 1 lógico la señal se mantiene y se desplaza al obtener un cero lógico.



"""